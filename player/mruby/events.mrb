module M
  class Event < Struct.new(:id, :type, :error, :data)
    %w(shutdown).each do |n|
      define_method("#{n}?") do
        type == n
      end
    end

    def success?
      error == "success"
    end
  end

  class FiberLoop
    def initialize
      @_fiber = Fiber.new do
        loop do; iter; end
      end
    end

    def suspend(*args)
      Fiber.yield(*args)
    end

    def call
      @_fiber.resume
    end
  end

  class EventSource < FiberLoop
    private
    def dequeue_event
      e = M.wait_event(1e20)
      M.puts.warn "dequeue_event: #{e.inspect}"
      suspend(e)
    end

    alias_method :iter, :dequeue_event
  end

  class EventLoop < FiberLoop
    def initialize(source)
      @_esource = source
      super()
    end

    private
    def iter
      event = @_esource.call
      suspend(:shutdown) if event.shutdown?
    end
  end

  def self.event_loop=(callable)
    @_event_loop = callable
  end

  def self.run
    @_event_loop ||= EventLoop.new(EventSource.new)
    @_event_loop.call
  end
end
